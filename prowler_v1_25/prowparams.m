function out=prowparams(varargin)
% function prowparams
% simulation parameter settings for prowler, invokes gui


% ***	
% ***	 Copyright 2002, Vanderbilt University. All rights reserved.
% ***
% ***    This program is distributed in the hope that it will be useful,
% ***    but WITHOUT ANY WARRANTY; without even the implied warranty of
% ***    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
% ***
% ***

% Written by Gyula Simon, gyula.simon@vanderbilt.edu
% Last modified: Dec 5, 2003  by GYS

if nargin <1
    command='init';
else
    command=varargin{1};
end

switch command
case 'init' 
    h_fig=paramgui;
    prowparams('select_active_params')
    curr_params=sim_params('get');
    prowparams('set_params_to_gui',curr_params)
    backup_current_settings;
    prowparams('plot_fx')
    set(h_fig, 'visible', 'on')
    figure(h_fig)
    
case 'check_edit'
    h=varargin{2};
    mode=varargin{3};
    str=get(h, 'string');
    val=str2num(str);
    [s1,s2]=size(val);
    if  s1+s2~=2 |...
            ((val<=0)&any(findstr(mode,'x>0')))  |...
            ((val<0 )&any(findstr(mode,'x>=0'))) |...
            ((val>1 )&any(findstr(mode,'x<=1'))) |...
            ((val<=1)&any(findstr(mode,'x>1')))
        set(h, 'string', get(h, 'userdata'));
    else
        set(h, 'userdata', str);
        if findstr(mode, 'refresh')
            prowparams('plot_fx')
        end
    end
case 'check_fx'
    h_fig=findall(0, 'tag', 'paramgui_fig');
    pars=getparams_from_gui; 
    fx=pars.SIGNAL_FCN;
    maxx=pars.PLOT_PARS_range;
    x=0:maxx/100:maxx;
    try
        signal_strength=eval(fx);
        out=[x(:), signal_strength(:)];
    catch
        out=nan;
        errordlg({'Bad expression for f(x):', lasterr}, 'Simulation parameters')
        error('Bad expression for f(x)')
    end
case 'plot_fx'
    xy=prowparams('check_fx');
    if ~any(any(isnan(xy)))
        pars=getparams_from_gui;
        s_alpha=pars.RADIO_SS_VAR_CONST;
        s_beta=pars.RADIO_SS_VAR_RAND;
        limit=pars.RECEPTION_LIMIT;
        
        h_fig=findall(0, 'tag', 'paramgui_fig');
        h_a=findobj(allchild(h_fig), 'flat', 'tag', 'paramgui_axes');
        h_linlog=findobj(allchild(h_fig), 'flat', 'tag', 'paramgui_PLOT_PARS_linlog');
        
        radio=sim_params('get', 'RADIO_NAME');
        x=xy(:,1);y=xy(:,2);
        plot(x,y, 'g', 'parent', h_a)
        set(h_a, 'nextplot', 'add');
        feval(radio, 'PropagationPlot', h_a, x)
        set(h_a, 'nextplot', 'replace');
        set(h_a, 'xlim', [0, xy(end,1)], 'ylimmode', 'manual', 'tag', 'paramgui_axes')
        if get(h_linlog,'value')==1 % linear
            set(h_a, 'yscale', 'lin')
        else
            set(h_a, 'yscale', 'log')
        end
        zoom(h_fig, 'on')    
    end
case 'add_radio_specific_UIC'  % additional inputs: h, label, property_to_set
    %return  % this function should be deactivated while editing figure
    h_UIC=varargin{2}; label_UIC=varargin{3}; property_UIC=varargin{4}; value_UIC = varargin{5};
    h_paramgui=findobj(allchild(0), 'tag', 'paramgui_fig');
    info_struct=struct('h', h_UIC, 'property', property_UIC, 'value', value_UIC);
    if ~isempty(h_paramgui)
        spec_list=getappdata(h_paramgui, 'radio_specific_UIC_list');
        if isempty(spec_list)  % create radio specific UIC list
            spec_list=struct(label_UIC, info_struct);
        else
            if isfield(spec_list, label_UIC)  % list entries for the label already exist; append
                spec_list=setfield(spec_list, label_UIC, [getfield(spec_list, label_UIC), info_struct]);
            else % create new list for the label
                spec_list=setfield(spec_list, label_UIC,  info_struct);
            end    
        end
        setappdata(h_paramgui, 'radio_specific_UIC_list', spec_list);
    end
    
case  'select_active_params'

    h_paramgui=findobj(allchild(0), 'tag', 'paramgui_fig');
    if ~isempty(h_paramgui)
       
        radio=sim_params('get', 'RADIO_NAME');
        radio_version=feval(radio, 'GetRadioVersion');
        
        spec_list=getfield(getappdata(h_paramgui, 'radio_specific_UIC_list'), radio_version);
       
        for i=1:length(spec_list)  % disable all radio specific UICs
            q=spec_list(i);
            set(q.h, q.property, q.value)
        end
    end
    
    
case 'set_params_to_gui'
    s=varargin{2};
    setparams_to_gui(s);
    
case 'getparams_from_gui'
    out=getparams_from_gui;
    
case 'apply'    
    prowparams('check_fx');
    pars=getparams_from_gui;
    sim_params('set_from_gui', pars);
    
    
case 'loadgui'
    try
        load paramgui_save
        setparams_to_gui(paramgui_save)
        prowparams('plot_fx')
        out=1;    
    catch
        out=0;
        errordlg({'Cannot load settings', lasterr}, 'Simulation parameters')
    end
    
case 'savegui'
    prowparams('check_fx');
    paramgui_save=getparams_from_gui;
    save paramgui_save paramgui_save
    
case 'loaddefault'
    def_params=sim_params('get_default');
    prowparams('set_params_to_gui',def_params)
    prowparams('plot_fx')
    
case 'help'
    GenerateHelp
otherwise
    error('Bad command for setparams')
end
   



function params=getparams_from_gui;
% returns parameter values set in GUI

h_fig=findall(0, 'tag', 'paramgui_fig');
ch=allchild(h_fig);
tags=get(ch, 'tag');

params=struct('tmptmp', 0);
for i=1:length(ch)
    h=ch(i);
    valid=0;
    if strcmp(get(h, 'type'), 'uicontrol')
        if strcmp(get(h, 'style'), 'edit')
            % edit box
            str=get(h, 'string');
            val=str2num(str);
            if isempty(val)
                val=str;
            end
            valid=1;
        elseif strcmp(get(h, 'style'), 'popupmenu')
            val=get(h, 'value');
            valid=1;
        end
    end
    if valid
        tag=get(h,'tag');
        name=tag(10:end);
        if strcmp(name, 'STOP_SIM_TIME')
            val=val/sim_params('get', 'BIT_TIME');
        end            
        params=setfield(params, name, val);
    end
end
params=rmfield(params, 'tmptmp');

function setparams_to_gui(s);

h_fig=findall(0, 'tag', 'paramgui_fig');
ch=allchild(h_fig);

names=fieldnames(s);
for i=1:length(names)
    name=names{i};
    objname=['paramgui_' name];
    h_gui_obj=findobj(ch, 'tag', objname);
    value=getfield(s, name);

    % exeptions:
    if strcmp(name, 'STOP_SIM_TIME')  % stop time is stored in bit-time units, but shown here in sec
        value= value*sim_params('get', 'BIT_TIME');
    end    
    if strcmp(get(h_gui_obj, 'style'), 'edit')
        if ~ischar(value) % number
            set(h_gui_obj, 'string', num2str(value));
        else 
            set(h_gui_obj, 'string', value);
        end
    elseif strcmp(get(h_gui_obj, 'style'), 'popup')
        set(h_gui_obj, 'value', value);
    end
end


function backup_current_settings

h_fig=findall(0, 'tag', 'paramgui_fig');
ch=allchild(h_fig);

edits=findobj(ch, 'style', 'edit');
for i=1:length(edits)
    set(edits(i), 'userdata', get(edits(i), 'string'))
end


function GenerateHelp
title1='Radio definition files';
str1={  'The following radio definition files are shipped with the simulator:'; ...
        '';...
        'radio_channel';...
        '   This definition file contains Channel model 1 with Fading model 1.';...
        '';...
        'radio_channel_SINR';...
        '   This definition file contains Channel model 2 with Fading model 1.';...
        '';...
        'radio_channel_Rayleigh_ND';...
        '   This definition file contains Channel model 2 with Fading model 2.';...
        ''};
        
title2='Propagation and fading models';
str2={  'The current implementation uses a basic model for radio propagation '; ...
        'with two different fading models.'; ...
        ''; ... 
        'In both cases the signal propagation is modeled by an ideal propagation'; ...
        'function, and disturbing components.';...
        ''; ... 
        'The ideal propagation function defines the signal strength ';...
        'vs. the distance between the transmitter and receiver.';...
        'The disturbance components model the fading effect.';...
        '';...
        '     f(x) is the ideal propagation function.';...
        '';...
        'The ideal received signal strength is';...
        '';...
        '     P_rec_id=P_transmit*f(x)';....
        '';...
        'where x is the distance.';....
        '';...
        'Fading Model 1';...
        '-------------------';...
        '';...
        'This model decribes scenarios where the motes have direct line of sight.'; ...
        '';...
        'The fading is modeled by adding noise components to the ';...
        'ideal received signal strength.';...
        'The received signal strength is';...
        '';...
        '     P_rec=P_rec_id*(1+alpha(x))*(1+beta(t)) ';...
        '';...
        'where alpha and beta are random variables with normal ';...
        'distributions N(0, s_alpha) and N(0, s_beta), respectively.';...
        '(P_rec is forced to be non-negative)';...
        '';...
        'Note that alpha models location-dependent effects, while';...
        'beta models time-dependent effects. The magnitude of the ';...
        'fading effect modeled by alpha remains constant during the ';...
        'simulation (unless location of the node changes, when it is ';...
        'recalculated), while the magnitude of the effect modeled by';...
        'beta changes in time.';...
        '';...
        'Fading Model 2 (Rayleigh fading)';...
        '-------------------------------------';...
        ''; ... 
        'This model decribes scenarios where the motes do not have direct line of sight.'; ...
        '';...
        'The fading is modeled by randomly modulating P_rec_id: ';...
        ''; ... 
        '     P_rec=P_rec_id*R ';...
        '';...
        'where R is a random variable with exponential distribution (mean = 1).';...
        '';...
        'There is a consistency time parameter (tau) defining the time';...
        'while the fading can be considered constant. P_rec is recalculated' ;...
        'for every transmitter mote in every tau time period.';...
        'If the position of a mote changes, the corresponding P_rec';...
        'values are recalculated.';...
        '';...
        '';...
        'An additional transmission error p_error is defined for both models.';...
        'It models all other sources/effects that may lead to an ';...
        'unsuccessful transmission.'; ...
        ''};
title3='Radio channel models';
str3={  'The simulator contains two different models to describe radio transmissions,'; ...
        'receptions, and collision avoidance.';...
        '';...
        'Channel Model 1 (simple)';...
        '-----------------';...
        '';...
        'This simple model is fast, although not very accurate.';...
        '';...
        'The following parameter can be set:'; ...
        '';...
        '     RECEPTION_LIMIT';...
        '';...
        'The signal from node k is successfully received if ';...
        '';...
        '     RECEIVED_POWER_k > RECEPTION_LIMIT, ';....
        'and';...
        '     RECEIVED_POWER_i < RECEPTION_LIMIT, i~=k';....
        '';...
        'during the time of the reception.';...
        '';...
        'Transmitters check the channel before starting ';...
        'transmission. The channel is considered idle if ';...
        '';...
        '     MRP < RECEPTION_LIMIT';...
        '';...
        'where MRP is the maximum received power at the time';...
        'of the idle check.';...
        '';...
        '';...
        '';...
        'Channel Model 2 (more detailed)';...
        '-----------------';...
        '';...
        'This model provides more accurate results at a somewhat slower speed.';...
        '';...
        'The following parameters can be set'; ...
        '';...
        '     SINR_LIMIT';...
        '     RNV';...
        '     IDLE_LIMIT_CONSTANT';...
        '';...
        'The Signal to Noise and Interference Ratio (SINR) is '; ...
        'defined by ';...
        '';...
        '     SINR=P_rec/(P_noise+P_int), where';....
        '';...
        ' P_rec is the power of the received (useful) signal, ';...
        ' P_noise is the receiver''s noise variance (RNV), and '; ...
        ' P_int is the total (summed) interference from all ';...
        ' the undesired transmitters.' ; ...
        '';...
        'The signal is successfully received if ';...
        '';...
        '     SINR > SINR_LIMIT, ';....
        '';...
        'during the time of the reception.';...
        '';...
        'Transmitters check the channel before starting ';...
        'transmission. The channel is considered idle if ';...
        '';...
        '     TRP < P_noise * IDLE_LIMIT_CONSTANT';...
        '';...
        'where TRP is the total received power (TRP) at the time';...
        'of the idle check.';...
        ''};


title4='MAC-layer model';
str4={  'The MAC-layer model uses 5 parameters:'; ...
        '';...
        '     MIN_WAITING_TIME';...
        '     VAR_WAITING_TIME';...
        '     MIN_BACKOFF_TIME';...
        '     VAR_BACKOFF_TIME';...
        '     PACKET_LENGTH';...
        '';...
        'The waiting time between channel request and channel idle ';...
        'check is between ';...
        '     MIN_WAITING_TIME and MIN_WAITING_TIME+VAR_WAITING_TIME.';...
        'Similarly, the backoff time after an unsuccessfull idle';...
        'check is between ';...
        '     MIN_BACKOFF_TIME and MIN_BACKOFF_TIME+VAR_BACKOFF_TIME.';...
        'The length of a single transmission is PACKET_LENGTH.';...
        '';...
        'All the MAC-layer parameters are measured in bit-times, ';....
        'where one bit-time  is the length of one transmitted bit in ';...
        'the radio channel (in the original TinyOS).';...
        'One bit-time equals to 1/40000 sec.';...
        ''};
title5='Other parameters';
str5={  'The following parameters affect the display:'; ...
        '';...
        '     LIN/LOG';...
        '     PLOT_RANGE';...
        '';...
        'LIN/LOG selects the yscale property of the axis. ';...
        'The x range is determined by PLOT_RANGE.';...
        '';...
        'The simulation stops at time SIM_STOP (in sec).';...
        ''};
helpwin({title1, str1; title2, str2; title3, str3; title4, str4; title5, str5}, 'Simulation parameters')
            
